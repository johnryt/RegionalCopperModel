import pandas as pd
import numpy as np
from scipy.stats import lognorm
from scipy.optimize import fsolve


# Lognormal mean function
def lognorm_mean(mu, sigma_to_mu, mean):
    sigma=sigma_to_mu*mu
    return np.exp(mu+sigma**2/2)-mean


# Calculate mu based on lognormal mean
def calc_mu(sigma_to_mu, mean, x0, **kwargs):
    return np.asscalar(fsolve(lognorm_mean, x0=x0, args=(sigma_to_mu, mean), **kwargs))


# Build lifetime dataframe
def lifetime_df(product_lifetime, sigma_to_mu=0.1, mu_0=3):
    product_lifetime_df=pd.DataFrame(0, index=product_lifetime.index, columns=['Lifetime', 'mu', 'sigma'])
    product_lifetime_df.loc[:, 'Lifetime']=product_lifetime.values

    for p in product_lifetime.index:
        lifetime_mean=product_lifetime.loc[p]
        mu=calc_mu(sigma_to_mu, mean=lifetime_mean, x0=mu_0)
        product_lifetime_df.loc[p, 'mu']=mu
        product_lifetime_df.loc[p, 'sigma']=mu*sigma_to_mu
        
    return product_lifetime_df


# Return lifetime lognormal distribution of each product, in discrete frequencies
def lifetime_freq_df(product_lifetime_df):
    lifetime_freq = pd.DataFrame(0, index=product_lifetime_df.index, columns=np.arange(0,200,1))
    # First year reaching end of life is year 0, which 
    for p in lifetime_freq.index:
        mu = product_lifetime_df.loc[p, 'mu']
        sigma = product_lifetime_df.loc[p, 'sigma']
        freqs = np.diff(lognorm.cdf(np.arange(0,201,1), s=sigma, loc=0, scale=np.exp(mu)))
        lifetime_freq.loc[p, :] = freqs
    
    return lifetime_freq


# Simulate product reaching end of life, for all history
def product_reach_eol(use_product, product_lifetime_freq_df):
    product_eol = pd.DataFrame(0, index=use_product.index, columns=use_product.columns)
    for y in product_eol.index:
        for p in product_eol.columns:
            enter_use = use_product.loc[y, p]
            eol_freq = product_lifetime_freq_df.loc[p,:]
            eol_gen = enter_use * eol_freq
            eol_gen.index=eol_gen.index+y

            product_eol.loc[y:2018, p] += eol_gen.loc[y:2018]
            
    return product_eol


# Simulate product reaching end of life, for one year
def product_reach_eol_oneyear(year_i, use_product, product_lifetime_freq_df):
    first_use_year=use_product.index[0]
    product_eol=pd.Series(0, index=use_product.columns)
    for p in product_eol.index:
        for year_enter_use in np.arange(first_use_year, year_i+1):
            enter_use = use_product.loc[year_enter_use, p]
            eol_freq = product_lifetime_freq_df.loc[p,:]
            eol_gen = enter_use*eol_freq
            eol_gen.index=eol_gen.index+year_enter_use

            product_eol.loc[p] += eol_gen.loc[year_i]
            
    return product_eol


# Calculate waste collected by type, based on product reaching end of life
def waste_collected_oneyear(product_eol_year_i, product_to_waste_collectable, sort_eff, collect_rate):
    waste_eol=pd.Series(np.matmul(product_eol_year_i, product_to_waste_collectable), 
                        index=product_to_waste_collectable.columns)
    waste_collected=waste_eol.mul(sort_eff).mul(collect_rate)
    return waste_collected


# New scrap simulation of one year
def simulate_new_scrap_one_year(year_i, use_product, new_scrap_gen_ratio, 
                                product_to_waste_no_loss, sort_eff,
                                home_scrap_ratio=0.45, exchange_scrap_ratio=0.45):
    use_product_year_i=use_product.loc[year_i, :]
    new_scrap_product=use_product_year_i.mul(new_scrap_gen_ratio)
    exchange_scrap_product=new_scrap_product.mul(exchange_scrap_ratio)
    external_scrap_product=new_scrap_product.mul(1-home_scrap_ratio-exchange_scrap_ratio)
    external_scrap_waste=\
    pd.Series(np.matmul(external_scrap_product, product_to_waste_no_loss), 
              index=product_to_waste_no_loss.columns).mul(sort_eff)
    exchange_scrap_waste=\
    pd.Series(np.matmul(exchange_scrap_product, product_to_waste_no_loss), 
              index=product_to_waste_no_loss.columns)
    new_scrap_waste=external_scrap_waste+exchange_scrap_waste
    return new_scrap_waste

# Old scrap generated by scrap type for initialization, original notebook: C:\Users\ryter\Dropbox (MIT)\Group Research Folder_Olivetti\Displacement\00 Simulation\06 Module integration\Other scenarios\China import ban\Order book initialization\Order book initialization.ipynb
def old_scrap_gen_init(product_eol_history, prod_to_waste, product_to_cathode_alloy, collect_rate, sort_eff, prod_spec, s2s, fraction_no1 = 0.1):
    idx = pd.IndexSlice
    waste_sectorial = pd.DataFrame(0,index=pd.MultiIndex.from_tuples(list(zip(sorted(list(product_eol_history.index)*\
                                   len(prod_to_waste.columns)),list(prod_to_waste.columns)*len(product_eol_history.index)))),
                                   columns=prod_to_waste.index)
    metal_recovered_sectorial = waste_sectorial.copy()
    for i in waste_sectorial.index.levels[0]:
        waste_sectorial.loc[idx[i,:],:] = (product_eol_history.loc[i,:]*prod_to_waste.transpose()).values
        for j in waste_sectorial.index.levels[1]:
            metal_recovered_sectorial.loc[idx[i,j],:] = waste_sectorial.loc[idx[i,j],:] * collect_rate[j]*sort_eff[j]
    
    # Getting rid of the waste classifications - for multi-indexed part
    metal_recovered = pd.DataFrame(0,index = metal_recovered_sectorial.index.levels[0],columns = metal_recovered_sectorial.columns)
    for i in metal_recovered_sectorial.index.levels[0]:
        metal_recovered.loc[i,:] = metal_recovered_sectorial.loc[idx[i,:],:].sum(axis=0)

    # Further Breakdown into Alloyed vs Unalloyed
    metal_recovered_sectorial_alloyed = metal_recovered.mul(product_to_cathode_alloy.loc[:,'Alloyed'])
    metal_recovered_sectorial_unalloyed = metal_recovered.mul(product_to_cathode_alloy.loc[:,'Copper']) 
    
    # Convert to shapes (only for alloyed scrap):
    metal_recovered_shapes_alloyed = pd.DataFrame(0,index = metal_recovered_sectorial_alloyed.index, columns = s2s.index)
    for i in metal_recovered_shapes_alloyed.index:
        metal_recovered_shapes_alloyed.loc[i,:] = (s2s.div(s2s.sum(axis=0)).fillna(0).
                                                   mul(metal_recovered_sectorial_alloyed.loc[i,:])).sum(axis=1)
    
    # Go from shape quantity to scrap alloy quantity:
    metal_recovered_scrap_alloyed = pd.DataFrame(0,index=metal_recovered_shapes_alloyed.index,\
            columns=sorted(prod_spec.loc[:,'Alloy Type'].unique()))
    alloy_annual = pd.DataFrame(0,index = metal_recovered_shapes_alloyed.index,columns = prod_spec.index)
    prod_spec.loc[:,'Quantity'] = 0
    for year_i in metal_recovered_shapes_alloyed.index:
        for i in metal_recovered_shapes_alloyed.columns:
            prod_spec.loc[prod_spec.loc[:,'Category']==i,'Quantity'] = prod_spec.loc[prod_spec.loc[:,'Category']==i,\
                                                'Fraction']*metal_recovered_shapes_alloyed.loc[year_i,i]
        for j in metal_recovered_scrap_alloyed.columns:
            metal_recovered_scrap_alloyed.loc[year_i,j] = prod_spec.loc[prod_spec.loc[:,'Alloy Type']==j,'Quantity'].sum()
        alloy_annual.loc[year_i,:] = prod_spec.loc[:,'Quantity'] # the quantities of each alloy generated in each year
        
    no1=(metal_recovered_sectorial_unalloyed*fraction_no1).sum(axis = 1).copy()
    no1.name = 'No.1'
    no2=(metal_recovered_sectorial_unalloyed*(1-fraction_no1)).sum(axis = 1).copy()
    no2.name = 'No.2'
    unalloyed=metal_recovered_sectorial_unalloyed.sum(axis=1).copy()
    unalloyed.name = 'Unalloyed'
    recovered_scrap = pd.concat([no1, no2, metal_recovered_scrap_alloyed],axis=1)
    
    return recovered_scrap

# Old scrap generated by scrap type for one year, original notebook: C:\Users\ryter\Dropbox (MIT)\Group Research Folder_Olivetti\Displacement\00 Simulation\06 Module integration\Other scenarios\China import ban\Order book initialization\Order book initialization.ipynb
def old_scrap_gen_oneyear(product_eol_year_i, prod_to_waste, product_to_cathode_alloy, collect_rate, sort_eff, prod_spec, s2s, fraction_no1 = 0.1):
    waste_sectorial_year = product_eol_year_i*prod_to_waste.transpose()
    metal_recovered_sectorial_year = pd.DataFrame(0,index = prod_to_waste.columns,columns=prod_to_waste.index)
    for j in waste_sectorial_year.index:
        metal_recovered_sectorial_year.loc[j,:] = waste_sectorial_year.loc[j,:] * collect_rate[j]*sort_eff[j]
    metal_recovered_sectorial_year = metal_recovered_sectorial_year.sum(axis=0)

    # Alloyed and unalloyed
    metal_recovered_sectorial_alloyed = metal_recovered_sectorial_year.mul(product_to_cathode_alloy.loc[:,'Alloyed'])
    metal_recovered_sectorial_unalloyed = metal_recovered_sectorial_year.mul(product_to_cathode_alloy.loc[:,'Copper'])

    # Conversion to shapes
    metal_recovered_shapes_alloyed = (s2s.div(s2s.sum(axis=0)).fillna(0)*
                                               metal_recovered_sectorial_alloyed).sum(axis=1)

    # Conversion to alloys
    metal_recovered_scrap_alloyed = pd.Series(0,index=sorted(prod_spec.loc[:,'Alloy Type'].unique()))
    alloy_annual = pd.Series(0,index = prod_spec.index)
    prod_spec.loc[:,'Quantity'] = 0
    for i in metal_recovered_shapes_alloyed.index:
        prod_spec.loc[prod_spec.loc[:,'Category']==i,'Quantity'] = prod_spec.loc[prod_spec.loc[:,'Category']==i,\
                                            'Fraction']*metal_recovered_shapes_alloyed.loc[i]
    # Conversion to scraps
    for j in metal_recovered_scrap_alloyed.index:
        metal_recovered_scrap_alloyed.loc[j] = prod_spec.loc[prod_spec.loc[:,'Alloy Type']==j,'Quantity'].sum()
    alloy_annual = prod_spec.loc[:,'Quantity'] # quantity for each alloy

    # Dealing with unalloyed portion and combining
    unalloyed = metal_recovered_sectorial_unalloyed 
    unalloyed = pd.Series({'No.1': (unalloyed*fraction_no1).sum(), 'No.2': (unalloyed*(1-fraction_no1)).sum()})
    return pd.concat([unalloyed, metal_recovered_scrap_alloyed])

# New scrap generated by scrap type for one year, original notebook: C:\Users\ryter\Dropbox (MIT)\Group Research Folder_Olivetti\Displacement\00 Simulation\06 Module integration\Other scenarios\China import ban\Order book initialization\Order book initialization.ipynb
def new_scrap_gen_oneyear(use_product_year_i, product_to_waste_no_loss, product_to_cathode_alloy, collect_rate, sort_eff, prod_spec, s2s, new_scrap_gen, exchange_scrap_ratio, home_scrap_ratio, fraction_no1 = 1, return_alloys = 0, fruity_alloys1 = 0):
    '''Set return_alloys = 2 to set fruity alloyed quantities to zero for RoW, any other nonzero to use fruity values. Leave those both empty to use the original version'''
    prod_spec1 = prod_spec.copy()
    new_scrap_product = use_product_year_i * new_scrap_gen
    exchange_scrap_product = new_scrap_product * exchange_scrap_ratio
    external_scrap_product = new_scrap_product * (1-home_scrap_ratio-exchange_scrap_ratio)
    new_scrap_waste = external_scrap_product + exchange_scrap_product

    external_scrap_prod_df = pd.DataFrame(0, index=product_to_waste_no_loss.columns, columns=product_to_waste_no_loss.index)

    # Applying sorting efficiency, since it is categorized by waste type
    external_scrap_metal_recovered = external_scrap_prod_df.copy()
    external_scrap_prod_df = (external_scrap_product*product_to_waste_no_loss.transpose())
    for j in external_scrap_prod_df.index:
        external_scrap_metal_recovered.loc[j,:] = external_scrap_prod_df.loc[j,:]*sort_eff[j]

    # Getting rid of dataframe
    external_scrap_metal_recovered = external_scrap_metal_recovered.sum()
    new_scrap_metal_recovered = external_scrap_metal_recovered + exchange_scrap_product

    # Further Breakdown into Alloyed vs Unalloyed
    new_scrap_metal_recovered_alloyed = new_scrap_metal_recovered*product_to_cathode_alloy.loc[:,'Alloyed']
    new_scrap_metal_recovered_unalloyed = new_scrap_metal_recovered*product_to_cathode_alloy.loc[:,'Copper']
    
    # Include fruity_alloys in new scrap generation
    if type(fruity_alloys1) == type(prod_spec1):
        fruity_alloys = fruity_alloys1.copy()
        if return_alloys == 2:
            fruity_alloys.loc[:,'Quantity'] = 0
        fruity_alloys.loc[:,'New scrap product'] = fruity_alloys.loc[:,'Quantity'] * new_scrap_gen.loc['Electronic']
        fruity_alloys.loc[:,'Exchange'] = fruity_alloys.loc[:,'New scrap product'] * exchange_scrap_ratio
        fruity_alloys.loc[:,'External'] = fruity_alloys.loc[:,'New scrap product'] * (1-home_scrap_ratio-exchange_scrap_ratio) * sort_eff['WEEE']
        fruity_alloys.loc[:,'Quantity'] = fruity_alloys.loc[:,'Exchange'] + fruity_alloys.loc[:,'External']
        fruity_alloys.loc[:,'Primary code'] = fruity_alloys.loc[:,'UNS']
        fruity_alloyed = fruity_alloys.copy().loc[fruity_alloys.loc[:,'Alloy Type']!='No.1']
        new_scrap_metal_recovered_unalloyed.loc['Electrical Automotive'] -= fruity_alloys.loc[fruity_alloys.loc[:,'Alloy Type']=='No.1', 'Quantity'].sum()
        if new_scrap_metal_recovered_alloyed.loc['Electronic'] > fruity_alloys.loc[:,'Quantity'].sum():
            new_scrap_metal_recovered_alloyed.loc['Electronic'] -= fruity_alloys.loc[:,'Quantity'].sum()
        else:
            new_scrap_metal_recovered_alloyed.loc['Diverse'] -= fruity_alloys.loc[:,'Quantity'].sum()
            
    # Convert to shapes (only for alloyed scrap):
    new_scrap_recovered_shapes_alloyed = pd.Series(0,index = s2s.index)
    new_scrap_recovered_shapes_alloyed = (s2s.div(s2s.sum(axis=0)).fillna(0)*new_scrap_metal_recovered_alloyed).sum(axis=1)
    
    # Go from shape quantity to scrap & alloy quantity:
    new_scrap_recovered_scrap_alloyed = pd.Series(0,index = sorted(prod_spec1.loc[:,'Alloy Type'].unique()))
    new_scrap_alloy_annual = pd.Series(0,index = prod_spec1.index)
    prod_spec1.loc[:,'Quantity'] = 0
    for i in new_scrap_recovered_shapes_alloyed.index:
        prod_spec1.loc[prod_spec1.loc[:,'Category']==i,'Quantity'] = prod_spec1.loc[prod_spec1.loc[:,'Category']==i,\
                                            'Fraction']*new_scrap_recovered_shapes_alloyed.loc[i]
    
    prod_spec1.loc['New No.1',:] = 0
    prod_spec1.loc['New No.1','Primary code'] = 'New No.1'
    prod_spec1.loc['New No.1','UNS'] = 'New No.1'
    prod_spec1.loc['New No.1','Alloy type'] = 'No.1'
    prod_spec1.loc['New No.1','Category'] = 'PSS'
    prod_spec1.loc['New No.1','High_Cu'] = 100
    prod_spec1.loc['New No.1','Low_Cu'] = 100
    prod_spec1.loc['New No.1','Quantity'] = (new_scrap_metal_recovered_unalloyed*fraction_no1).sum()
    #prod_spec1.loc['New No.1',:]['New No.1','New No.1','New No.1','No.1','PSS',100,100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,(new_scrap_metal_recovered_unalloyed*fraction_no1).sum()]


    if type(fruity_alloys1) == type(prod_spec1):
        for i in fruity_alloys.index:
            prod_spec1.loc[i,:] = fruity_alloys.loc[i]
            
    if return_alloys != 0:
        new_scrap_alloys = prod_spec1.loc[:,['Primary code','Alloy Type','High_Cu', 'Low_Cu', 'High_Zn', 'Low_Zn', 'High_Pb', 'Low_Pb',
           'High_Sn', 'Low_Sn', 'High_Ni', 'Low_Ni', 'High_Al', 'Low_Al',
           'High_Mn', 'Low_Mn', 'High_Fe', 'Low_Fe', 'Quantity']].copy()
        if type(fruity_alloys) != type(0):
            new_scrap_alloys.loc[fruity_alloys.index,'Primary code'] = fruity_alloys.index
        new_scrap_alloys.drop_duplicates('Primary code', inplace = True, keep = 'first')
        new_scrap_alloys.index = new_scrap_alloys.loc[:,'Primary code']
        new_scrap_alloys.drop(columns = 'Primary code', inplace = True)
        new_scrap_alloys.rename(columns = {'Quantity': 'Availability'}, inplace=True)
        if np.nan in new_scrap_alloys.index:
            new_scrap_alloys.drop(np.nan, inplace = True)
        for i in new_scrap_alloys.index:
            new_scrap_alloys.loc[i,'Availability'] = prod_spec1.loc[prod_spec1.loc[:,'Primary code']==i, 'Quantity'].sum()
        new_scrap_alloys.fillna(0, inplace = True)    
        
    for j in new_scrap_recovered_scrap_alloyed.index:
        new_scrap_recovered_scrap_alloyed.loc[j] = prod_spec1.loc[prod_spec1.loc[:,'Alloy Type']==j,'Quantity'].sum()
    new_scrap_alloy_annual = prod_spec1.loc[:,'Quantity'] # for individual alloys

    # Finishing up with unalloyed and concatenating
    unalloyed = new_scrap_metal_recovered_unalloyed
    unalloyed = pd.Series({'No.1': (unalloyed*fraction_no1).sum(), 'No.2': (unalloyed*(1-fraction_no1)).sum()})
    new_scrap_avail_oneyear = pd.concat([unalloyed, new_scrap_recovered_scrap_alloyed])
    if return_alloys == 0:
        return new_scrap_avail_oneyear
    else:
        return new_scrap_avail_oneyear, new_scrap_alloys
    
    
def alloy_to_scrap(new_scrap_alloys, new_scrap_alloys_year_i):
    scrap_quantities = pd.DataFrame(0, index = new_scrap_alloys.index, columns = new_scrap_alloys_year_i.loc[:,'Alloy Type'].unique())
    for i in new_scrap_alloys.columns:
        col = new_scrap_alloys_year_i.loc[new_scrap_alloys_year_i.index == i,'Alloy Type'].iloc[0]
        scrap_quantities.loc[:,col] += new_scrap_alloys.loc[:, i]
    return scrap_quantities
    
def alloy_to_scrap_1yr(new_scrap_alloys, new_scrap_alloys_year_i):
    scrap_quantities = pd.Series(0, index = new_scrap_alloys_year_i.loc[:,'Alloy Type'].unique())
    for i in new_scrap_alloys.index:
        col = new_scrap_alloys_year_i.loc[new_scrap_alloys_year_i.index == i,'Alloy Type'].iloc[0]
        scrap_quantities.loc[col] += new_scrap_alloys.loc[i]
    return scrap_quantities
